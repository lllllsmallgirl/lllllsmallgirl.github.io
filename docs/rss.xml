<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Miles的博客</title><link>https://lllllsmallgirl.github.io</link><description>记录工作和学习中遇到的问题，方便复盘</description><copyright>Miles的博客</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://avatars.githubusercontent.com/u/70518807?v=4</url><title>avatar</title><link>https://lllllsmallgirl.github.io</link></image><lastBuildDate>Tue, 12 Nov 2024 05:26:22 +0000</lastBuildDate><managingEditor>Miles的博客</managingEditor><ttl>60</ttl><webMaster>Miles的博客</webMaster><item><title>turbo repo 学习笔记1</title><link>https://lllllsmallgirl.github.io/post/turbo%20repo%20-xue-xi-bi-ji-1.html</link><description>monorepo概念：单仓 同时管理多个项目&#13;
turbo repo：采用monorepo的项目管理框架&#13;
&#13;
## 安装&#13;
1. 全局安装turbo：npm install turbo --global&#13;
2. 创建一个turborepo项目：npx create-turbo@latest&#13;
&#13;
## 创建内部package&#13;
在packages文件夹下，新建文件夹，然后创建package.json&#13;
```&#13;
'exports':{&#13;
    './add': './src/add.ts&#13;
}&#13;
```&#13;
创建出口，就是对外暴露的方法&#13;
&#13;
在应用文件夹中的package.json中添加本地依赖，添加后一定记得pnpm i，把本地的包引入！！！&#13;
至此，就可以在应用文件中使用本地自己创建的package。</description><guid isPermaLink="true">https://lllllsmallgirl.github.io/post/turbo%20repo%20-xue-xi-bi-ji-1.html</guid><pubDate>Tue, 12 Nov 2024 05:24:02 +0000</pubDate></item><item><title>test</title><link>https://lllllsmallgirl.github.io/post/test.html</link><description>### test。</description><guid isPermaLink="true">https://lllllsmallgirl.github.io/post/test.html</guid><pubDate>Tue, 12 Nov 2024 05:06:57 +0000</pubDate></item><item><title>展开/收起 效果</title><link>https://lllllsmallgirl.github.io/post/zhan-kai---shou-qi-%20-xiao-guo.html</link><description>## 使用css实现展开收起效果&#13;
&#13;
```html&#13;
&lt;button (click)='toggleExpand()'&gt;Toggle Expand&lt;/button&gt;&#13;
&lt;div class='content' [ngClass]='{'expanded': isExpanded, 'collapsed': !isExpanded}'&gt;&#13;
  &lt;!-- Your content goes here --&gt;&#13;
&lt;/div&gt;&#13;
```&#13;
&#13;
```css&#13;
.content {&#13;
  background-color: #f0f0f0;&#13;
  border: 1px solid #ccc;&#13;
  max-height: 0;&#13;
  overflow: hidden;&#13;
  transition: max-height 0.3s ease-out;&#13;
}&#13;
&#13;
.expanded {&#13;
  max-height: 200px; /* Adjust the height as per your content */&#13;
}&#13;
&#13;
.collapsed {&#13;
  max-height: 0;&#13;
}&#13;
```&#13;
&#13;
```ts&#13;
export class YourComponent {&#13;
&#13;
  isExpanded = false;&#13;
&#13;
  toggleExpand() {&#13;
    this.isExpanded = !this.isExpanded;&#13;
  }&#13;
}&#13;
```&#13;
主要是使用max-height来实现的，比较巧妙，遂记录于此。</description><guid isPermaLink="true">https://lllllsmallgirl.github.io/post/zhan-kai---shou-qi-%20-xiao-guo.html</guid><pubDate>Thu, 04 Jul 2024 00:01:19 +0000</pubDate></item><item><title>有向图判断是否存在闭环</title><link>https://lllllsmallgirl.github.io/post/you-xiang-tu-pan-duan-shi-fou-cun-zai-bi-huan.html</link><description>## 递归tree&#13;
最近在工作中遇到tree的节点是否能选择其他节点作为父节点的问题，下面简单描述一下问题： &#13;
一个无环有向树形数据结构，本身是有方向的，可以看做具有流的性质，也就是说子节点必须发生在父节点之后，&#13;
现在的需求是**将这个树变成有环有向树，但是不允许出现有向环（也就是从某个顶点出发无法回到该顶点）**&#13;
&#13;
&#13;
具体思路：深度优先搜索来判断是否存在环&#13;
```js&#13;
function hasCycle(graph) {&#13;
  const visited = new Set();&#13;
  const stack = new Set();&#13;
&#13;
  function dfs(node) {&#13;
    if (stack.has(node)) {&#13;
      return true; // 当前节点在递归堆栈中，表示存在环&#13;
    }&#13;
    if (visited.has(node)) {&#13;
      return false; // 当前节点已经被访问过，不存在环&#13;
    }&#13;
&#13;
    visited.add(node); // 标记当前节点为已访问&#13;
    stack.add(node); // 将当前节点添加到递归堆栈中&#13;
&#13;
    for (let neighbor of graph[node] || []) {&#13;
      if (dfs(neighbor)) {&#13;
        return true;&#13;
      }&#13;
    }&#13;
&#13;
    stack.delete(node); // 当前节点递归结束，从堆栈中移除&#13;
    return false;&#13;
  }&#13;
&#13;
  for (let node in graph) {&#13;
    if (dfs(node)) {&#13;
      return true;&#13;
    }&#13;
  }&#13;
&#13;
  return false;&#13;
}&#13;
&#13;
```&#13;
&#13;
&#13;
辅助函数 dfs遍历树&#13;
```js&#13;
const findAllNode = (tree) =&gt; {&#13;
    const nodes = [];&#13;
    const dfs = (node) =&gt; {&#13;
        nodes.push(node.id);&#13;
        nodes.children.forEach(child =&gt; dfs(child));&#13;
    }&#13;
    dfs(tree);&#13;
    return nodes;&#13;
}&#13;
```。</description><guid isPermaLink="true">https://lllllsmallgirl.github.io/post/you-xiang-tu-pan-duan-shi-fou-cun-zai-bi-huan.html</guid><pubDate>Thu, 27 Jun 2024 12:11:23 +0000</pubDate></item><item><title>angular的嵌套订阅</title><link>https://lllllsmallgirl.github.io/post/angular-de-qian-tao-ding-yue.html</link><description>## 使用switchMap来简化嵌套订阅&#13;
&#13;
```js&#13;
this.userService.getUser().pipe(&#13;
  switchMap(user =&gt; this.orderService.getOrders(user.id))&#13;
).subscribe(orders =&gt; {&#13;
  console.log(orders);&#13;
});&#13;
```。</description><guid isPermaLink="true">https://lllllsmallgirl.github.io/post/angular-de-qian-tao-ding-yue.html</guid><pubDate>Tue, 25 Jun 2024 07:11:41 +0000</pubDate></item><item><title>视频画中画</title><link>https://lllllsmallgirl.github.io/post/shi-pin-hua-zhong-hua.html</link><description>## 视频画中画（Picture-in-Picture）&#13;
&#13;
在项目中，遇到这样一个需求：&#13;
&#13;
实现类似b站视频播放的效果，即视频点击播放后，页面向下滚动至视频盒子消失在浏览器视口时，自动弹出画中画效果，当页面向上滚动至视频盒子出现在视口时，取消画中画效果&#13;
&#13;
&#13;
经过调查，发现一套浏览器自带的画中画API，&#13;
```js&#13;
// 进入画中画&#13;
video.requestPictureInPicture();&#13;
// 退出画中画&#13;
document.exitPictureInPicture();&#13;
```&#13;
于是尝试进行使用，测试了一下发现第一次使用完全ok，&#13;
&#13;
**问题**：页面向上滚动恢复原视频盒子后，再次向下滚动页面就无法触发画中画的开启，并且控制台报错：NotAllowedError: Must be handling a user gesture to request picture in picture. &#13;
&#13;
经过调查，发现出现这个问题的原因如下：&#13;
&#13;
该API规定只有用户与页面交互后，才能触发，有点类似视频自动播放无法开启音量  &#13;
scroll也就是滚动事件并不是浏览器认为的**被用户信任的事件**（不算与页面产生交互），而点击事件是。</description><guid isPermaLink="true">https://lllllsmallgirl.github.io/post/shi-pin-hua-zhong-hua.html</guid><pubDate>Tue, 25 Jun 2024 00:55:34 +0000</pubDate></item><item><title>blog测试</title><link>https://lllllsmallgirl.github.io/post/blog-ce-shi.html</link><description>This is a test page~。</description><guid isPermaLink="true">https://lllllsmallgirl.github.io/post/blog-ce-shi.html</guid><pubDate>Fri, 21 Jun 2024 07:46:46 +0000</pubDate></item></channel></rss>